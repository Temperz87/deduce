module Nat

import Option
import Base
public import NatDefs
public import NatAdd
public import NatMonus
public import NatMult
public import NatLess
public import NatDiv

/*
 Properties of Summation
 */

theorem summation_cong: all k : Nat. all f : fn Nat->Nat, g : fn Nat->Nat, s : Nat, t : Nat. 
  if (all i:Nat. if i < k then f(s + i) = g(t + i))
  then summation(k, s, f) = summation(k, t, g)
proof
  induction Nat
  case zero {
    arbitrary f:fn(Nat) -> Nat,g:fn(Nat) -> Nat,s:Nat,t:Nat
    suppose f_g
    expand summation.
  }
  case suc(k') suppose IH {
    arbitrary f:fn(Nat) -> Nat,g:fn(Nat) -> Nat,s:Nat,t:Nat
    suppose f_g
    show summation(suc(k'),s,f) = summation(suc(k'),t,g)
    suffices f(s) + summation(k',suc(s),f) = g(t) + summation(k',suc(t),g)
      by expand summation.
    have f_g_s: f(s) = g(t) by
       (apply f_g[zero] to expand operator < | 2* operator ≤.)
    have IH': summation(k',suc(s),f) = summation(k',suc(t),g)
      by apply IH[f,g,suc(s),suc(t)] 
         to arbitrary i:Nat suppose i_k: i < k'
            suffices f(suc(s + i)) = g(suc(t + i))  by evaluate
            have fsi_gtsi: f(s + suc(i)) = g(t + suc(i))
              by suffices suc(i) < suc(k') by f_g[suc(i)] 
                 apply less_suc_iff_suc_less to i_k
            replace add_suc  in fsi_gtsi
    replace f_g_s | IH'.
  }
end

lemma summation_cong4: all k:Nat. all f : fn Nat->Nat, g : fn Nat->Nat, s :Nat. 
  if (all i:Nat. if s ≤ i and i < s + k then f(i) = g(i))
  then summation(k, s, f) = summation(k, s, g)
proof
  induction Nat
  case zero {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat
    suppose _
    expand summation.
  }
  case suc(k') suppose IH {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat
    suppose f_g: all i:Nat. if s ≤ i and i < s + suc(k') then f(i) = g(i)
    suffices f(s) + summation(k',suc(s),f) = g(s) + summation(k',suc(s),g)
        by expand summation.
    have f_g_s: f(s) = g(s) by {
      have s_s: s ≤ s by less_equal_refl[s]
      have s_sk: s < s + suc(k') by {
        suffices s ≤ s + k' by {
          expand operator < | operator ≤
          replace add_suc.
        }
        less_equal_add[s][k']
      }
      apply f_g[s] to s_s, s_sk
    }
    have IH': summation(k',suc(s),f) = summation(k',suc(s),g) by {
      have IH_prem: all i:Nat. if (suc(s) ≤ i and i < suc(s) + k')
                               then f(i) = g(i) by
      {
        arbitrary i:Nat
        suppose ss_i_and_i_ss_k
        have s_i: s ≤ i by {
          apply less_implies_less_equal[s][i]
          to suffices suc(s) ≤ i  by expand operator <.
          ss_i_and_i_ss_k
        } 
        have i_s_k: i < s + suc(k') by {
          suffices suc(i) ≤ suc(s + k')  by {
            suffices __ by evaluate
            replace add_suc.
          }
          suffices i ≤ s + k' by evaluate
          evaluate in (conjunct 1 of ss_i_and_i_ss_k)
        }
        conclude f(i) = g(i) by apply f_g[i] to s_i, i_s_k
      }
      apply IH[f,g,suc(s)] to IH_prem
    }
    replace f_g_s | IH'.
  }
end

lemma summation_suc:
  all k:Nat. all f : fn Nat->Nat, g : fn Nat->Nat, s :Nat. 
  if (all i:Nat. f(i) = g(suc(i)))
  then summation(k, s, f) = summation(k, suc(s), g)
proof
  arbitrary k:Nat
  arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat
  suppose prem
  have sum_prem: (all i:Nat. (if i < k then f(s + i) = g(suc(s) + i))) by
      arbitrary i:Nat
      suppose i_less_k
      suffices f(s+i) = g(suc(s+i))  by expand operator+.
      prem[s+i]
  apply summation_cong[k][f, g, s, suc(s)] to sum_prem
end

lemma summation_cong3: all k:Nat. all f : fn Nat->Nat, g : fn Nat->Nat, s :Nat, t :Nat. 
  if (all i:Nat. f(s + i) = g(t + i))
  then summation(k, s, f) = summation(k, t, g)
proof
  induction Nat
  case zero {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat, t :Nat
    suppose _
    expand summation.
  }
  case suc(k') suppose IH {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat, t :Nat
    suppose f_g: all i:Nat. f(s + i) = g(t + i)
    suffices f(s) + summation(k',suc(s),f) = g(t) + summation(k',suc(t),g)
      by expand summation.
    have fs_gt: f(s) = g(t)   by f_g[zero]
    have all_f_g: all i:Nat. f(suc(s) + i) = g(suc(t) + i) by {
      arbitrary i:Nat
      suffices f(suc(s + i)) = g(suc(t + i))  by expand operator +.
      replace add_suc in f_g[suc(i)]
    }
    equations
          f(s) + summation(k',suc(s),f)
        = g(t) + summation(k',suc(s),f)   by replace fs_gt.
    ... = g(t) + summation(k',suc(t),g)   by replace (apply IH[f,g,suc(s),suc(t)] to all_f_g).
  }
end

theorem summation_add:
  all a:Nat. all b:Nat, s:Nat, t:Nat, f:fn Nat->Nat, g:fn Nat->Nat, h:fn Nat->Nat.
  if (all i:Nat. if i < a then g(s + i) = f(s + i))
  and (all i:Nat. if i < b then h(t + i) = f(s + a + i))
  then summation(a + b, s, f) = summation(a, s, g) + summation(b, t, h)
proof
  induction Nat
  case zero {
    arbitrary b:Nat, s:Nat, t:Nat, f:fn Nat->Nat, g:fn Nat->Nat, h:fn Nat->Nat
    suppose g_f_and_h_f
    suffices summation(b,s,f) = summation(b,t,h)
      by expand summation.
    apply summation_cong[b][f,h,s,t]
    to arbitrary i:Nat
       suppose i_b: i < b
       conclude f(s + i) = h(t + i)
       by symmetric (apply (conjunct 1 of g_f_and_h_f)[i] to i_b)
  }
  case suc(a') suppose IH {
    arbitrary b:Nat, s:Nat, t:Nat, f:fn Nat->Nat, g:fn Nat->Nat, h:fn Nat->Nat
    suppose g_f_and_h_f
    suffices f(s) + summation(a' + b,suc(s),f) = (g(s) + summation(a',suc(s),g)) + summation(b,t,h)
        by expand operator + | summation.
    have fs_gs: f(s) = g(s) by symmetric
        apply (conjunct 0 of g_f_and_h_f)[zero]
        to expand operator < | 2* operator ≤.
    have IH': summation(a' + b,suc(s),f)
            = summation(a',suc(s),g) + summation(b,t,h)
      by have p1: all i:Nat. (if i < a' then g(suc(s) + i) = f(suc(s) + i))
           by arbitrary i:Nat suppose i_a: i < a'
              have i_sa : suc(i) < suc(a') by 
                apply less_suc_iff_suc_less to i_a
              replace add_suc | symmetric suc_add[s, i]
                in apply (conjunct 0 of g_f_and_h_f)[suc(i)] to i_sa
         have p2: all i:Nat. (if i < b then h(t + i) = f(suc(s) + (a' + i)))
           by arbitrary i:Nat suppose i_b: i < b
              expand 2*operator+
              expand operator+ in
              replace add_suc in
              apply (conjunct 1 of g_f_and_h_f)[i] to i_b
         apply IH[b,suc(s),t,f,g,h] to p1, p2
    replace fs_gs | IH' .
  }
end

lemma summation_suc_add: all n:Nat, s:Nat, f:fn Nat->Nat.
  summation(suc(zero) + n, s, f) = summation(n, s, f) + f(s + n)
proof
  arbitrary n:Nat, s:Nat, f:fn Nat->Nat
  have A: (all i:Nat. (if i < n then f(s + i) = f(s + i))) by {
    arbitrary i:Nat assume: i < n .
  }
  have B: (all i:Nat. (if i < suc(zero) then f((s + n) + i) = f(s + (n + i)))) by {
    arbitrary i:Nat assume: i < suc(zero) .
  }
  have C: summation(n + suc(zero), s, f) = summation(n, s, f) + summation(suc(zero), s+n, f)
    by apply summation_add[n,suc(zero),s,s+n,f,f,f] to A,B
  have D: summation(suc(zero), s + n, f) = f(s + n) by {
    expand 2*summation.
  }
  replace add_commute[suc(zero),n] | C | D.
end

/*
 Properties of equal
*/
theorem equal_refl: all n:Nat. equal(n,n)
proof
  induction Nat
  case zero {
    expand equal.
  }
  case suc(n') suppose IH {
    suffices equal(n',n')  by expand equal.
    IH
  }
end

theorem equal_complete_sound : all m:Nat. all n:Nat.
  m = n ⇔ equal(m, n)
proof
  induction Nat
  case zero {
    arbitrary n:Nat
    switch n {
      case zero { expand equal. }
      case suc(n') { expand equal. }
    }
  }
  case suc(m') suppose IH {
    arbitrary n:Nat 
    switch n {
      case zero { expand equal. }
      case suc(n') {
        have right : (if suc(m') = suc(n') then equal(suc(m'), suc(n')))
          by suppose sm_sn: suc(m') = suc(n')
             suffices equal(m', n')  by expand equal.
             have m_n: m' = n' by injective suc sm_sn
             suffices equal(n', n')  by replace m_n.
             equal_refl[n']
        have left : (if equal(suc(m'), suc(n')) then suc(m') = suc(n'))
          by suppose sm_sn : equal(suc(m'), suc(n'))
             have e_m_n : equal(m', n') by expand equal in sm_sn
             have m_n : m' = n' by apply IH to e_m_n
             replace m_n.
        right, left
      }
    }
  }
end

theorem not_equal_not_eq: all m:Nat, n:Nat.
  if not equal(m, n) then not (m = n)
proof
  arbitrary m:Nat, n:Nat
  suppose not_m_n
  suppose m_n
  have eq_m_n: equal(m, n) by {
    suffices equal(n,n)  by replace m_n.
    equal_refl[n]
  }
  apply not_m_n to eq_m_n
end


/*
 Properties of pow2
 */
 
lemma pow_positive: all n:Nat. zero < pow2(n)
proof
  induction Nat
  case zero {
    evaluate
  }
  case suc(n') suppose IH {
    suffices zero < suc(suc(zero)) * pow2(n')  by expand pow2.
    obtain pn' where pn_s: pow2(n') = suc(pn')
        from apply positive_suc[pow2(n')] to IH
    suffices zero < suc(suc(zero)) * suc(pn')  by replace pn_s.
    suffices zero < suc(pn') + (suc(pn') + zero)  by expand operator*.
    suffices zero < suc(pn') + suc(pn')  by .
    suffices zero < suc(pn' + suc(pn'))  by expand operator+.
    suffices zero < suc(suc(pn' + pn'))  by replace add_suc[pn'][pn'].
    evaluate
  }
end


/* 
  Properties of exponentiation
  https://rocq∸prover.org/doc/v8.9/stdlib/Coq.Numbers.NatInt.NZPow.html
  and
  https://coq.kwarc.info/Coq.Numbers.NatInt.NZPow.html
  */

lemma expt_one : all n : Nat.
  n ^ suc(zero) = n
proof
  arbitrary n : Nat
  suffices n * suc(zero) = n by evaluate
  mult_one
end

lemma one_expt : all n : Nat.
  suc(zero) ^ n = suc(zero)
proof
  induction Nat
  case zero {
    evaluate
  }
  case suc(n') assume IH {
    have IH' : expt(n', suc(zero)) = suc(zero) by expand operator^ in IH
    suffices suc(zero) * expt(n', suc(zero)) = suc(zero) by expand operator^ | expt.
    replace IH'.
  }
end

theorem pow_add_r : all n : Nat, m : Nat, o : Nat.
  m ^ (n + o) = m ^ n * m ^ o
proof
  induction Nat
  case zero {
    arbitrary m : Nat, o : Nat
    suffices expt(o, m) = expt(o, m) + zero by evaluate
    .
  }
  case suc(n') assume IH {
    arbitrary m : Nat, o : Nat
    have IH' : (all m':Nat, o':Nat. expt(n' + o', m') = expt(n', m') * expt(o', m')) 
      by expand operator^ in IH
    suffices  m * expt(n' + o, m) = m * expt(n', m) * expt(o, m) 
      by expand operator^ | operator+ | expt.
    replace IH'.
  }
end

theorem pow_mul_l : all o : Nat, m : Nat, n : Nat.
  (m * n) ^ o = m ^ o * n ^ o
proof
  induction Nat
  case zero {
    evaluate
  }
  case suc(o') assume IH {
    arbitrary m : Nat, n : Nat
    have IH' : (all m':Nat, n':Nat. expt(o', m' * n') = expt(o', m') * expt(o', n')) 
      by evaluate in IH
    suffices  m * n * expt(o', m * n) = m * expt(o', m) * n * expt(o', n) by evaluate
    replace IH' | mult_commute[n, expt(o', m)].
  }
end

theorem pow_mul_r : all o : Nat, m : Nat, n : Nat.
  (m ^ n) ^ o = m ^ (n * o)
proof
  induction Nat
  case zero {
    arbitrary m : Nat, n : Nat
    suffices (m ^ n) ^ zero = m ^ zero by .
    evaluate
  }
  case suc(o') assume IH {
    arbitrary m : Nat, n : Nat
    have IH' :  (all m':Nat, n':Nat. expt(o', expt(n', m')) = expt(n' * o', m')) 
      by expand operator^ in IH
    suffices expt(n, m) * expt(n * o', m) = expt(n + n * o', m) by {
      expand operator^ | expt
      replace mult_suc[n, o'] | IH'.
    }
    symmetric expand operator^ in pow_add_r[n, m, n * o']
  }
end

lemma pow_pos_nonneg : all b : Nat, a : Nat.
  if zero<a then zero<a^b
proof
  induction Nat
  case zero {
    evaluate
  }
  case suc(b') assume IH {
    arbitrary a : Nat
    assume prem
    suffices zero < a * expt(b', a) by expand operator^ | expt.
    have exp_nz : zero < expt(b', a) by expand operator^ in apply IH to prem
    apply mult_pos_nonneg to prem, exp_nz
  }
end


lemma pow_zero_l : all a : Nat. if zero<a then zero^a = zero
proof
  arbitrary a : Nat
  switch a {
    case zero {
      evaluate
    }
    case suc(n') {
      evaluate
    }
  }
end


lemma pow_eq_zero : all n : Nat, m : Nat.
  if m ^ n = zero then m = zero
proof
  induction Nat
  case zero {
    evaluate
  }
  case suc(n') assume IH {
    arbitrary m : Nat
    switch m {
      case zero assume eq_z_t {
        evaluate
      }
      case suc(m') assume eq_sn_t {
        assume contra
        have contra' : suc(m') * expt(n', suc(m')) = zero 
          by expand operator^ | expt in contra
        have e_n_sm_z : expt(n', suc(m')) = zero by apply mult_to_zero to contra'
        have IH' : all m'':Nat. if expt(n', m'') = zero then m'' = zero 
          by expand operator^ in IH
        conclude false by apply IH'[suc(m')] to e_n_sm_z
      }
    }
  }
end

lemma exp_one_implies_zero_or_one : all m : Nat, n : Nat.
  if m ^ n = suc(zero) then n = zero or m = suc(zero)
proof 
  arbitrary m : Nat, n : Nat
  switch n {
    case zero  {
      .
    }
    case suc(n') {
      suffices  (if m * expt(n', m) = suc(zero) then m = suc(zero)) by evaluate
      assume prem
      apply one_mult_one to prem
    }
  }
end

lemma pow_lt_mono_l : all  c : Nat, a : Nat, b : Nat.
  if zero < c then if a < b then a ^ c < b ^ c
proof
  induction Nat
  case zero {
    evaluate
  }
  case suc(n') assume IH {
    arbitrary a : Nat, b : Nat
    assume z_l_sc
    assume alb
    switch zero < n' {
      case true assume prop_t {
        suffices a * expt(n', a) < b * expt(n', b) 
          by expand operator^ | expt.
        have ena_l_enb : expt(n', a) < expt(n', b) 
          by expand operator^ in apply (replace prop_t in IH) to alb
        have enb_nz :  expt(n', b) > zero by {
          expand operator >
          apply greater_any_zero to ena_l_enb
        }
        have bnz : zero < b 
          by apply greater_any_zero to alb
        have step1 : a * expt(n', a) <= a * expt(n', b)
          by apply mult_mono_le[a, expt(n', a), expt(n', b)] to 
            (apply less_implies_less_equal to ena_l_enb)
        have step2 : a * (expt(n',b)) < b * expt(n', b) 
          by apply (apply mult_lt_mono_l[expt(n', b), a, b] to enb_nz) to alb

        cases (apply less_equal_implies_less_or_equal to step1) 
        case step1':  a * expt(n', a) < a * expt(n', b) {
          apply less_trans[a * expt(n', a), a * expt(n', b)] to step1', step2
        }
        case step1'':  a * expt(n', a) = a * expt(n', b) {
          replace symmetric step1'' in step2
        }
      }
      case false assume prop_f {
        have nz : n' = zero by replace prop_f in zero_or_positive[n']
        suffices a < b by replace nz | expt_one.
        alb
      }
    }
  }
end

lemma pow_gt_1 : all n : Nat, m : Nat.
  if suc(zero) < n then (zero < m <=> suc(zero) < n ^ m)
proof
  arbitrary n : Nat, m : Nat
  assume prem
  have l : if zero < m then suc(zero) < n ^ m by {
    assume zlm
    replace symmetric one_expt[m]
    show suc(zero)^m < n^m
    suffices suc(zero) < n by apply pow_lt_mono_l[m, suc(zero), n] to zlm
    prem
  }
  have r : if suc(zero) < n ^ m then zero < m by {
    assume nm_g1
    cases zero_or_positive[m]
    case zm : m = zero {
      evaluate in replace zm in nm_g1 
    }
    case : zero < m { recall zero < m }
  }
  r, l
end

theorem pow_le_mono_l : all c : Nat, a : Nat, b : Nat.
  if a <= b then a ^ c <= b ^ c
proof 
  induction Nat
  case zero {
    evaluate
  }
  case suc(n') assume IH {
    arbitrary a : Nat, b : Nat
    assume a_le_b
    suffices  a * expt(n', a) ≤ b * expt(n', b) 
      by expand operator^ | expt.
    have step : expt(n', a) <= expt(n', b)
      by expand operator^ in (apply IH to a_le_b)
    have step1 : a * expt(n', a) <= a * expt(n', b)
      by apply mult_mono_le[a, expt(n', a), expt(n', b)] to step
    have step2 : a * expt(n', b) <= b * expt(n', b)
      by apply mult_mono_le_r[expt(n', b), a, b] to a_le_b
    apply less_equal_trans[a * expt(n', a), a * expt(n', b)] to step1, step2
  }
end

lemma pow_lt_mono_r : all c : Nat, a : Nat, b : Nat.
  if suc(zero) < a then if b < c then a^b < a^c
proof
  arbitrary c : Nat, a : Nat, b : Nat
  assume prem
  assume blc
  have blec : b <= c by apply less_implies_less_equal to blc
  obtain x where step from apply le_exists_monus to blec
  replace step | pow_add_r | mult_commute[a^b, a^x]
  show suc(zero) * a ^ b < a ^ x * suc(zero) * a ^ b
  have zla : zero < a by {
    have zl1 : zero < suc(zero) by evaluate
    apply less_trans[zero, suc(zero), a] to zl1, prem
  }
  have : a ^ b > zero by {
    expand operator>
    apply pow_pos_nonneg[b, a] to zla
  }
  suffices suc(zero) < a^x * suc(zero)
    by (apply mult_lt_mono_l[a^b, suc(zero), a^x * suc(zero)] to recall a^b > zero)
  have zlx : zero < x by {
    cases zero_or_positive[x]
    case xz : x = zero {
      have cb : c = b by replace xz in step
      apply less_irreflexive to replace cb in blc 
    }
    case : zero < x { recall zero < x }
  }
  replace symmetric mult_one[a^x] in apply (apply pow_gt_1[a, x] to prem) to zlx
end

lemma pow_inj_l : all a : Nat, b : Nat, c : Nat.
  if zero < c then (if a^c = b^c then a = b)
proof
  arbitrary a : Nat, b : Nat, c : Nat
  assume zlc
  assume ac_eq_bc
  cases trichotomy[a, b]
  case : a < b {
    have contra : a^c < b^c by apply (apply pow_lt_mono_l[c, a, b] to zlc) to (recall a < b)
    apply less_irreflexive to replace ac_eq_bc in contra
  }
  case : a = b { recall a = b }
  case : b < a {
    have contra : b^c < a^c by apply (apply pow_lt_mono_l[c, b, a] to zlc) to (recall b < a)
    apply less_irreflexive to replace ac_eq_bc in contra
  }
end

lemma pow_inj_r : all a : Nat, b : Nat, c : Nat.
  if suc(zero) < a then if a^b = a ^ c then b = c
proof
  arbitrary a : Nat, b : Nat, c : Nat
  assume ola
  assume ab_eq_ac
  cases trichotomy[b, c]
  case : b < c {
    apply less_irreflexive to
      replace ab_eq_ac in
      apply apply pow_lt_mono_r[c,a,b] to ola to recall b < c
  }
  case : b = c { recall b = c }
  case : c < b {
    apply less_irreflexive to
      replace ab_eq_ac in
      apply apply pow_lt_mono_r[b,a,c] to ola to recall c < b
  }
end

/*
  Greatest Common Divisor
*/

recfun gcd(a : Nat, b : Nat) -> Nat
  measure b of Nat
{
  if b = zero then a
  else gcd(b, a % b)
}
terminates {
  arbitrary a:Nat, b:Nat
  assume bnz: not (b = zero)
  have b_pos: zero < b  by apply or_not to zero_or_positive[b], bnz
  conclude a % b < b by apply mod_less_divisor[a,b] to b_pos
}

theorem gcd_divides: all b:Nat, a:Nat. divides(gcd(a,b), a) and divides(gcd(a,b), b)
proof
  define P = fun b':Nat {all a:Nat. divides(gcd(a,b'), a) and divides(gcd(a,b'), b')}
  have X: all j:Nat. (if (all i:Nat. (if i < j then P(i))) then P(j)) by {
    arbitrary j:Nat
    assume IH: all i:Nat. (if i < j then P(i))
    expand P
    switch j {
      case zero {
        arbitrary a:Nat
        have A: divides(gcd(a, zero), a) by {
          expand divides | gcd
          choose suc(zero)
          conclude a * suc(zero) = a  by mult_one
        }
        have B: divides(gcd(a, zero), zero) by {
          expand divides | gcd
          choose zero
          conclude a * zero = zero  by mult_zero
        }
        A, B
      }
      case suc(j') assume j_suc {
        arbitrary a:Nat
        replace symmetric j_suc
        have j_pos: zero < j by {
          replace recall j = suc(j')
          evaluate
        }
        have smaller: a % j < j
          by apply mod_less_divisor[a,j] to j_pos
        have div_j_div_aj: divides(gcd(j, a % j), j) and divides(gcd(j, a % j), a % j)
          by (expand P in apply IH[a%j] to smaller)[j]
        have A: divides(gcd(a, j), a) by {
          replace j_suc expand gcd replace symmetric j_suc
          conclude divides(gcd(j, a % j), a)
            by apply divides_mod[gcd(j, a % j), a, j] to div_j_div_aj, j_pos
        }
        have B: divides(gcd(a, j), j) by {
          replace j_suc expand gcd replace symmetric j_suc
          conclude divides(gcd(j, a % j), j) by div_j_div_aj
        }
        A, B
      }
    }
  }
  arbitrary b:Nat
  expand P in apply strong_induction[P,b] to X
end

/*
  Properties of log
  */

lemma add_less_equal_pow_find_log: all m:Nat. all n:Nat, l:Nat.
  if n ≤ pow2(l)
  then m + n ≤ pow2(find_log(m, n, l))
proof
  induction Nat
  case zero {
    arbitrary n:Nat, l:Nat
    suppose n_le_pl: n ≤ pow2(l)
    suffices n ≤ pow2(l)
        by expand find_log.
    n_le_pl
  }
  case suc(m') suppose IH {
    arbitrary n:Nat, l:Nat
    suppose prem
    switch pow2(l) < suc(n) for find_log {
      case true {
        have sn_le_spl: suc(n) ≤ suc(pow2(l)) by {
          suffices n ≤ pow2(l) by expand operator ≤.
          prem
        }
        obtain p where pl_sp: pow2(l) = suc(p) from
          (apply positive_suc[pow2(l)] to pow_positive[l])
        have sn_le_psl: suc(n) ≤ pow2(suc(l)) by {
          suffices suc(n) ≤ suc(p) + suc(p) by {
            expand pow2 | operator*
            replace pl_sp.
          }
          suffices n ≤ pow2(l) + p by {
            expand operator+ | operator≤
            replace symmetric pl_sp | add_commute[p][pow2(l)].
          }
          apply less_equal_trans[n][pow2(l), pow2(l) + p] 
          to prem, less_equal_add[pow2(l)][p]
        }
        have IH': m' + suc(n) ≤ pow2(find_log(m',suc(n),suc(l)))
          by apply IH[suc(n),suc(l)] to sn_le_psl
        conclude suc(m') + n ≤ pow2(find_log(m',suc(n),suc(l))) by {
          suffices suc(m' + n) ≤ pow2(find_log(m', suc(n), suc(l)))
            by expand operator+.
          replace add_suc[m'][n] in IH'
        }
      }
      case false suppose pl_l_sn_false {
        have not_pl_l_sn: not (pow2(l) < suc(n)) by {
          suppose pl_l_sn
          conclude false by replace pl_l_sn_false in pl_l_sn
        }
        have sn_le_pl: suc(n) ≤ pow2(l)
          by apply not_less_implies_less_equal[pow2(l)][suc(n)] to not_pl_l_sn
        have IH': m' + suc(n) ≤ pow2(find_log(m',suc(n),l))
          by apply IH[suc(n), l] to sn_le_pl
        conclude suc(m') + n ≤ pow2(find_log(m',suc(n),l)) by {
          suffices suc(m' + n) ≤ pow2(find_log(m', suc(n), l))
            by expand operator +.
          replace add_suc[m'][n] in IH'
        }
      }
    }
  }
end

theorem less_equal_pow_log: all n:Nat.
  n ≤ pow2(log(n))
proof
  arbitrary n:Nat
  suffices n ≤ pow2(find_log(n, zero, zero)) by expand log.
  have f1: n + zero ≤ pow2(find_log(n, zero, zero))
    by apply add_less_equal_pow_find_log[n][zero,zero] to
       apply less_implies_less_equal[ zero ][pow2(zero)] to pow_positive[ zero ]
  conclude n ≤ pow2(find_log(n,zero,zero))
    by { evaluate in f1 }
end

/*
  Support for automatic arithmetic on literals
*/

// Invariant: only apply lit to a literal Nat.
fun lit(a : Nat) { a }

theorem nat_zero_add: all y:Nat.
  lit(zero) + lit(y) = lit(y)
proof
  arbitrary y:Nat
  expand lit.
end

auto nat_zero_add

theorem lit_suc_add: all x:Nat, y:Nat.
  lit(suc(x)) + lit(y) = lit(suc(lit(x) + lit(y)))
proof
  arbitrary x:Nat, y:Nat
  expand lit
  suc_add
end

auto lit_suc_add

theorem suc_lit: all n:Nat. suc(lit(n)) = lit(suc(n))
proof
  arbitrary n:Nat
  expand lit.
end

auto suc_lit

theorem lit_idem: all x:Nat.
  lit(lit(x)) = lit(x)
proof
  arbitrary x:Nat
  expand lit.
end

auto lit_idem

theorem nat_zero_mult: all y:Nat.
  lit(zero) * lit(y) = lit(zero)
proof
  arbitrary y:Nat
  expand lit.
end

auto nat_zero_mult

theorem nat_one_mult: all n:Nat.
  lit(suc(zero)) * n = n
proof
  arbitrary n:Nat
  expand lit.
end

auto nat_one_mult

theorem nat_mult_one: all n:Nat.
  n * lit(suc(zero)) = n
proof
  arbitrary n:Nat
  expand lit.
end

auto nat_mult_one

theorem lit_suc_mult: all m:Nat, n:Nat.
  lit(suc(m)) * lit(n) = lit(n) + lit(m) * lit(n)
proof
  arbitrary m:Nat, n:Nat
  expand lit | operator*.
end

auto lit_suc_mult

theorem lit_mult_lit_suc: all m:Nat, n:Nat.
  lit(m) * lit(suc(n)) = lit(m) + lit(m) * lit(n)
proof
  arbitrary m:Nat, n:Nat
  expand lit
  mult_suc
end

auto lit_mult_lit_suc

theorem lit_mult_suc: all m:Nat, n:Nat.
  lit(m) * suc(n) = lit(m) + lit(m) * n
proof
  arbitrary m:Nat, n:Nat
  expand lit
  mult_suc
end

auto lit_mult_suc

theorem nat_zero_monus: all m:Nat.
  lit(zero) ∸ lit(m) = lit(zero)
proof
  arbitrary m:Nat
  expand lit | operator∸.
end

theorem nat_monus_zero: all n:Nat.
  n ∸ lit(zero) = n
proof
  arbitrary n:Nat
  expand lit
  monus_zero
end

auto nat_monus_zero

theorem lit_suc_monus_suc: all n:Nat, m:Nat.
  lit(suc(n)) ∸ lit(suc(m)) = lit(n) ∸ lit(m)
proof
  arbitrary n:Nat, m:Nat
  expand lit | operator∸.
end

auto lit_suc_monus_suc

theorem lit_dist_mult_add:
  all a:Nat, x:Nat, y:Nat.
  lit(a) * (x + y) = lit(a) * x + lit(a) * y
proof
  arbitrary a:Nat, x:Nat, y:Nat
  expand lit
  dist_mult_add
end

auto lit_dist_mult_add

theorem lit_dist_mult_add_right:
  all x:Nat, y:Nat, a:Nat.
  (x + y) * lit(a) = x * lit(a) + y * lit(a)
proof
  arbitrary x:Nat, y:Nat, a:Nat
  expand lit
  dist_mult_add_right
end

auto lit_dist_mult_add_right

theorem mult_two: all n:Nat.
  n + n = lit(suc(suc(zero))) * n
proof
  arbitrary n:Nat
  expand lit
  replace two_mult.
end

theorem lit_suc_add2: all x:Nat, y:Nat.
  suc(lit(x) + y) = lit(suc(x)) + y
proof
  arbitrary x:Nat, y:Nat
  expand lit
  replace suc_add.
end

// This causes problem with pattern matching in switch. -Jeremy
//auto lit_suc_add2

theorem nat_suc_one_add: all n:Nat.
  suc(n) = lit(suc(zero)) + n
proof
  arbitrary n:Nat
  expand lit
  suc_one_add
end

// The following causes infinite loop for
// lit(x) * lit(y)

// theorem lit_mult_commute: all n:Nat, m:Nat.
//   n * lit(m) = lit(m) * n
// proof
//   arbitrary n:Nat, m:Nat
//   expand lit
//   mult_commute
// end

// auto lit_mult_commute

theorem lit_add_suc: all n:Nat, m:Nat.
  lit(n) + suc(m) = lit(suc(n)) + m
proof
  arbitrary n:Nat, m:Nat
  expand lit
  replace add_suc
  expand operator+.
end

auto lit_add_suc

theorem lit_mult_left_cancel : all m : Nat, a : Nat, b : Nat.
  if lit(suc(m)) * a = lit(suc(m)) * b then a = b
proof
  arbitrary m : Nat, a : Nat, b : Nat
  expand lit
  mult_left_cancel
end

/*
  More Properties of Summation
  */

theorem sum_n : all n : Nat. 
    ℕ2 * summation(n, ℕ0, λ x {x}) = n * (n ∸ ℕ1)
proof
    induction Nat
    case zero {
        evaluate
    }
    case suc(n') suppose IH {
      have step1: (all i:Nat. (if i < ℕ1 then n' + i = ℕ0 + (n' + i))) by {
        arbitrary i:Nat
        suppose prem : i < ℕ1
        evaluate
      }
      replace nat_suc_one_add[n']
      | add_commute[ℕ1, n']
      | apply summation_add[n', ℕ1, ℕ0, n', λn{n}, λn{n}, λn{n}] to step1
      | IH
      expand lit | 2* summation
      replace nat_suc_one_add | add_commute[n', ℕ1]
      replace add_monus_identity
      replace nat_suc_one_add | dist_mult_add_right
      replace mult_commute[n', n' ∸ ℕ1]
      replace symmetric dist_mult_add_right[n' ∸ ℕ1, ℕ2, n']
      switch n' {
        case zero {
          .
        }
        case suc(n'') {
          replace nat_suc_one_add | add_monus_identity
          replace dist_mult_add | dist_mult_add_right
          replace mult_two
          replace add_commute[n'', ℕ1] | add_commute[n'', ℕ2] | add_commute[n'' * n'', ℕ2 * n''].
        }
      }
    }
end

theorem sum_n' : all n : Nat. 
    ℕ2 * summation(suc(n), ℕ0, λ x {x}) = n * (n + ℕ1)
proof
    induction Nat
    case zero {
      expand 2* summation | lit.
    }
    case suc(n') suppose IH {
      have step1: (all i:Nat. (if i < ℕ1 then suc(n') + i = ℕ0 + (suc(n') + i))) by {
        arbitrary i:Nat
        suppose prem : i < ℕ1
        replace nat_suc_one_add.
      }
      replace nat_suc_one_add
      replace (replace add_commute[n',ℕ1] in (apply summation_add[ℕ1 + n'][ℕ1, ℕ0, suc(n'), λn{n}, λn{n}, λn{n}] to step1))
      replace (replace nat_suc_one_add in IH)
      expand lit | 2*summation
      replace nat_suc_one_add | dist_mult_add | dist_mult_add_right
      replace dist_mult_add[n', n', ℕ1] | add_commute[ℕ1, n' + n'] | mult_two[n']
      | add_commute[ℕ2 * n', ℕ2] | add_commute[ℕ2 + ℕ2 * n', n' * n' + n'].
    }
end

/*
  Public versions of theorems involving literals
*/

theorem pos_mult_left_cancel : all m : Nat, a : Nat, b : Nat.
  if ℕ0 < m and m * a = m * b then a = b
proof
  arbitrary m : Nat, a : Nat, b : Nat
  assume prem
  switch m {
    case zero assume mz {
      conclude false by evaluate in replace mz in prem
    }
    case suc(m') assume ms {
      apply mult_left_cancel[m', a, b] to replace ms in prem
    }
  }
end

theorem pos_mult_right_cancel_less : all c : Nat, a : Nat, b : Nat.
  if ℕ0 < c and a * c < b * c then a < b
proof
  arbitrary c : Nat, a : Nat, b : Nat
  expand lit
  assume prem
  apply (apply mult_lt_mono_r[c,a,b] to prem) to prem
end

theorem pos_mult_left_cancel_less_equal : all n : Nat, x : Nat, y : Nat.
  if ℕ0 < n and n * x ≤ n * y then x ≤ y
proof
  arbitrary n : Nat, x : Nat, y : Nat
  expand lit
  assume prem  
  obtain n' where ns: n = suc(n') from apply positive_suc[n] to prem
  apply mult_nonzero_mono_le[n', x, y] to (replace ns in prem)
end
  
theorem pos_mult_both_sides_of_less : all n : Nat, x : Nat, y : Nat.
  if ℕ0 < n and x < y then n * x < n * y
proof
  arbitrary n : Nat, x : Nat, y : Nat
  expand lit
  assume prem
  obtain n' where ns: n = suc(n') from apply positive_suc[n] to prem
  replace ns
  apply mono_nonzero_mult_le[n', x, y] to (replace ns in prem)
end
  
theorem nat_zero_less_one_add: all n:Nat.
  ℕ0 < ℕ1 + n
proof
  arbitrary n:Nat
  expand lit
  zero_less_one_add
end

theorem nat_add_to_zero: all n:Nat, m:Nat.
  if n + m = ℕ0
  then n = ℕ0 and m = ℕ0
proof
  arbitrary n:Nat, m:Nat
  expand lit
  add_to_zero
end

theorem nat_less_add_pos: all x:Nat, y:Nat.
  if ℕ0 < y
  then x < x + y
proof
  arbitrary x:Nat, y:Nat
  expand lit
  less_add_pos
end

theorem nat_monus_zero_iff_less_eq : all x : Nat, y : Nat.
  x ≤ y  ⇔  x ∸ y = ℕ0
proof
  arbitrary x : Nat, y : Nat
  expand lit
  monus_zero_iff_less_eq[x, y]
end

theorem nat_monus_one_pred : all x : Nat. x ∸ ℕ1 = pred(x)
proof
  arbitrary x:Nat
  expand lit
  monus_one_pred
end

theorem nat_monus_cancel: all n:Nat. n ∸ n = ℕ0
proof
  arbitrary n:Nat
  expand lit
  monus_cancel
end

theorem nat_zero_or_positive: all x:Nat. x = ℕ0 or ℕ0 < x
proof
  arbitrary x:Nat
  expand lit
  zero_or_positive[x]
end

theorem nat_not_one_add_zero: all n:Nat.
  not (ℕ1 + n = ℕ0)
proof
  arbitrary n:Nat
  expand lit
  not_one_add_zero[n]
end

theorem nat_positive_suc: all n:Nat.
  if ℕ0 < n
  then some n':Nat. n = ℕ1 + n'
proof
  arbitrary n:Nat
  expand lit
  assume prem
  expand operator+
  apply positive_suc[n] to prem
end

theorem nat_zero_le_zero: all x:Nat. if x ≤ ℕ0 then x = ℕ0
proof
  arbitrary x:Nat
  expand lit
  zero_le_zero
end
  
theorem summation_next: all n:Nat, s:Nat, f:fn Nat->Nat.
  summation(ℕ1 + n, s, f) = summation(n, s, f) + f(s + n)
proof
  arbitrary n:Nat, s:Nat, f:fn Nat->Nat
  expand lit
  summation_suc_add
end

theorem less_zero_false: all x:Nat. (x < zero) = false
proof
  arbitrary x:Nat
  apply eq_false to not_less_zero[x]
end

auto less_zero_false
  
theorem zero_less_equal_true: all x:Nat. (zero ≤ x) = true
proof
  arbitrary x:Nat
  expand operator≤.
end

auto zero_less_equal_true

postulate less_lit_suc: all x:Nat, y:Nat. (lit(suc(x)) < lit(suc(y))) = (lit(x) < lit(y))
auto less_lit_suc  

postulate less_lit_zero_suc: all y:Nat. (lit(zero) < lit(suc(y))) = true
auto less_lit_zero_suc

postulate lit_zero_div: all x:Nat. lit(zero) / lit(suc(x)) = lit(zero)
auto lit_zero_div

postulate lit_div_cancel: all y:Nat. lit(suc(y)) / lit(suc(y)) = lit(suc(zero))
auto lit_div_cancel

fun add_div(a : Nat, b : Nat, y : Nat) { (a + b) / y } // invariant: a ≤ y
fun frac(x : Nat, y : Nat) { x / y } // invariant: x < y

postulate lit_div: all x:Nat, y:Nat. lit(x) / lit(y) = add_div(zero, x, y)
auto lit_div

postulate lit_add_div: all b:Nat, y:Nat. add_div(y, b, y) = lit(suc(zero)) + add_div(zero, b, y)
auto lit_add_div

postulate lit_add_div_suc: all a:Nat, b:Nat, y:Nat. add_div(a, suc(b), y) = add_div(suc(a), b, y)
auto lit_add_div_suc

postulate lit_add_div_frac: all a:Nat, y:Nat. add_div(a, zero, y) = frac(lit(a), lit(y))
auto lit_add_div_frac

postulate lit_frac_zero: all y:Nat. frac(lit(zero), lit(y)) = lit(zero)
auto lit_frac_zero

theorem lit_less_zero_false: all x:Nat. (x < lit(zero)) = false
proof
  arbitrary x:Nat
  expand lit.
end

auto lit_less_zero_false

theorem lit_zero_less_equal_true: all x:Nat. (lit(zero) ≤ x) = true
proof
  arbitrary x:Nat
  expand lit.
end

auto lit_zero_less_equal_true
