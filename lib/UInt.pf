module UInt

import Base
import Nat
public import UIntDefs
public import UIntToFrom
public import UIntLess
public import UIntAdd
public import UIntMult
public import UIntMonus
public import UIntPowLog

// Need lit, zero, suc following for unsigned integer literals.

export lit
export zero
export suc

lemma uint_pred_inc: all b:UInt.
  pred(inc(b)) = b
proof
  arbitrary b:UInt
  suffices toNat(pred(inc(b))) = toNat(b) by toNat_injective
  replace toNat_pred | toNat_inc
  show pred(suc(toNat(b))) = toNat(b)
  expand pred.
end

lemma inc_one_add: all b:UInt.
  inc(b) = inc_dub(bzero) + b
proof
  arbitrary b:UInt
  suffices toNat(inc(b)) = toNat(inc_dub(bzero) + b) by toNat_injective
  replace toNat_inc | toNat_add
  expand 2*toNat
  show suc(toNat(b)) = suc(ℕ2 * ℕ0) + toNat(b)
  evaluate
end
  
lemma uint_ind: all P:fn UInt -> bool, k : Nat, n : UInt.
  if n = fromNat(k) then
  if P(0) and (all m:UInt. if P(m) then P(1 + m)) then P(n)
proof
  arbitrary P:fn UInt -> bool
  induction Nat
  case zero {
    arbitrary n:UInt
    assume nz
    assume base_IH
    replace nz

    suffices __ by evaluate
    expand lit | fromNat in conjunct 0 of base_IH
  }
  case suc(k') assume IH {
    arbitrary n:UInt
    assume n_sk
    assume base_IH
    have n_ik: n = inc(fromNat(k')) by expand fromNat in n_sk
    have eq0: pred(n) = pred(inc(fromNat(k'))) by replace n_ik.
    have eq1: pred(n) = fromNat(k') by replace uint_pred_inc in eq0
    have: P(pred(n)) by apply (apply IH[pred(n)] to eq1) to base_IH
    have eq2: P(1 + pred(n))
      by apply (conjunct 1 of base_IH)[pred(n)] to recall P(pred(n))
    have eq3: 1 + pred(n) = n by expand lit | 2*fromNat replace eq1 | n_ik | inc_one_add.
    conclude P(n) by replace eq3 in eq2
  }
end

theorem uint_induction: all P:fn UInt -> bool, n : UInt.
  if P(0) and (all m:UInt. if P(m) then P(1 + m)) then P(n)
proof
  arbitrary P:fn UInt -> bool, n : UInt
  assume prem
  have eq: n = fromNat(toNat(n)) by replace from_toNat.
  apply (apply uint_ind[P, toNat(n), n] to eq) to prem
end

theorem less_fromNat: all x:Nat, y:Nat.
  if x < y
  then fromNat(x) < fromNat(y)
proof
  arbitrary x:Nat, y:Nat
  assume x_y
  have A: toNat(fromNat(x)) < toNat(fromNat(y)) by {
    replace to_fromNat
    x_y
  }
  conclude fromNat(x) < fromNat(y) by apply less_toNat to A
end
  
postulate less_equal_fromNat: all x:Nat, y:Nat.
  if x ≤ y
  then fromNat(x) ≤ fromNat(y)
  
theorem uint_zero_or_positive: all x:UInt. x = 0 or 0 < x
proof
  arbitrary x:UInt
  have z_p: toNat(x) = ℕ0 or ℕ0 < toNat(x) by nat_zero_or_positive[toNat(x)]
  cases z_p
  case z {
    have A: fromNat(toNat(x)) = 0 by { replace z evaluate }
    conclude x = 0 by replace from_toNat in A
  }
  case p {
    have A: 0 < fromNat(toNat(x)) by {
      replace from_zero in apply less_fromNat to p
    }
    conclude 0 < x by replace from_toNat in A
  }
end

theorem uint_less_plus1: all n:UInt.
  n < 1 + n
proof
  arbitrary n:UInt
  suffices toNat(n) < toNat(1 + n) by less_toNat[n, 1 + n]
  replace toNat_add
  suffices toNat(n) ≤ toNat(n) by evaluate
  less_equal_refl
end

theorem uint_add_both_sides_of_less: all x:UInt, y:UInt, z:UInt.
  x + y < x + z ⇔ y < z
proof
  arbitrary x:UInt, y:UInt, z:UInt
  have fwd: if x + y < x + z then y < z by {
    assume prem
    have A: toNat(x + y) < toNat(x + z) by apply toNat_less[x+y,x+z] to prem
    have B: toNat(x) + toNat(y) < toNat(x) + toNat(z) by replace toNat_add in A
    have C: toNat(y) < toNat(z) by apply add_both_sides_of_less to B
    conclude y < z by apply less_toNat to C
  }
  have bkwd: if y < z then x + y < x + z by {
    assume prem
    have A: toNat(y) < toNat(z) by apply toNat_less[y,z] to prem
    have B: toNat(x) + toNat(y) < toNat(x) + toNat(z)
      by apply add_both_sides_of_less[toNat(x)] to A
    have C: toNat(x + y) < toNat(x + z) by {
      replace toNat_add
      B
    }
    conclude x + y < x + z by apply less_toNat to C
  }
  fwd, bkwd
end

theorem less_is_less_equal: all x:UInt, y:UInt.
  x < y = 1 + x ≤ y
proof
  arbitrary x:UInt, y:UInt
  suffices x < y ⇔ 1 + x ≤ y by iff_equal
  have fwd: if (x < y) then (1 + x ≤ y) by {
    assume prem
    have A: toNat(x) < toNat(y) by apply toNat_less to prem
    have C: ℕ1 + toNat(x) ≤ toNat(y) by {
      replace nat_suc_one_add in
      expand operator< in A
    }
    have D: fromNat(ℕ1 + toNat(x)) ≤ fromNat(toNat(y))
      by apply less_equal_fromNat to C
    have E: 1 + fromNat(toNat(x)) ≤ fromNat(toNat(y))
      by replace fromNat_add[ℕ1, toNat(x)] | from_one in D
    conclude 1 + x ≤ y by replace from_toNat in E
  }
  have bkwd: if (1 + x ≤ y) then (x < y) by {
    assume prem
    have A: toNat(1 + x) ≤ toNat(y) by apply toNat_less_equal to prem
    have B: toNat(1) + toNat(x) ≤ toNat(y) by replace toNat_add in A
    have C: toNat(1) = ℕ1 by evaluate
    have D: ℕ1 + toNat(x) ≤ toNat(y) by replace C in B
    have E: toNat(x) < toNat(y) by {
      expand operator<
      replace nat_suc_one_add
      D
    }
    conclude x < y by apply less_toNat to E
  }
  fwd, bkwd
end

theorem uint_monus_add_identity: all n:UInt. all m:UInt.
  if m ≤ n
  then m + (n ∸ m) = n
proof
  arbitrary n:UInt, m:UInt
  assume prem
  suffices toNat(m + (n ∸ m)) = toNat(n) by toNat_injective
  suffices toNat(m) + toNat(n ∸ m) = toNat(n) by replace toNat_add.
  suffices toNat(m) + (toNat(n) ∸ toNat(m)) = toNat(n) by replace toNat_monus.
  have A: toNat(m) ≤ toNat(n) by apply toNat_less_equal to prem
  conclude toNat(m) + (toNat(n) ∸ toNat(m)) = toNat(n)
    by apply monus_add_identity to A
end

theorem uint_not_one_add_zero: all n:UInt.
    not (1 + n = 0)
proof
  arbitrary n:UInt
  assume prem
  have eq1: toNat(1 + n) = toNat(0) by replace prem.
  have eq2: toNat(1) + toNat(n) = toNat(0) by replace toNat_add in eq1
  have eq3: ℕ1 + toNat(n) = ℕ0 by evaluate in eq2
  conclude false by apply nat_not_one_add_zero to eq3
end

postulate uint_zero_le_zero: all x:UInt. (if x ≤ 0 then x = 0)

theorem uint_not_one_add_le_zero: all n:UInt.
  not (1 + n ≤ 0)
proof
  arbitrary n:UInt
  assume prem
  apply uint_not_one_add_zero[n] to
  apply uint_zero_le_zero to prem
end

theorem uint_not_zero_pos: all n:UInt.
  if not (n = 0) then 0 < n
proof
  arbitrary n:UInt
  assume prem
  switch n {
    case bzero assume nz {
      conclude false by expand lit | fromNat in replace nz in prem
    }
    case dub_inc(n') {
      evaluate
    }
    case inc_dub(n') {
      evaluate
    }
  }
end

theorem uint_pos_not_zero: all n:UInt.
  if 0 < n then not (n = 0)
proof
  arbitrary n:UInt
  assume n_pos
  assume prem
  have zz: 0 < 0 by replace prem in n_pos
  conclude false by apply uint_less_irreflexive to zz
end

    
recfun operator /(n : UInt, m : UInt) -> UInt
  measure n of UInt
{
  if n < m then 0
  else if m = 0 then 0
  else 1 + ((n ∸ m) / m)
}
terminates {
  arbitrary n:UInt, m:UInt
  assume cond: not (n < m) and not (m = 0)
  suffices m + (n ∸ m) < m + n by uint_add_both_sides_of_less[m,n∸m,n]
  suffices n < m + n by {
    have m_n: m ≤ n by apply uint_not_less_implies_less_equal to conjunct 0 of cond
    replace apply uint_monus_add_identity[n,m] to m_n.
  }
  have m_pos: 0 < m by apply uint_not_zero_pos to conjunct 1 of cond
  conclude n < m + n by {
    replace uint_add_commute in
    apply uint_less_add_pos[n, m]
    to expand lit | fromNat in m_pos
  }
}

fun operator % (n:UInt, m:UInt) {
  n ∸ (n / m) * m
}

postulate inc_add_one: all n:UInt.
  inc(n) = 1 + n

theorem uint_pos_implies_one_le: all n:UInt.
  if 0 < n
  then 1 ≤ n
proof
  arbitrary n:UInt
  assume n_pos
  have A: 1 + 0 ≤ n by replace less_is_less_equal in n_pos
  A
end

theorem uint_positive_add_one: all n:UInt.
  if 0 < n
  then some n':UInt. n = 1 + n'
proof
  arbitrary n:UInt
  assume n_pos
  have pos_n: ℕ0 < toNat(n) by expand lit | fromNat | toNat in apply toNat_less to n_pos
  obtain x where eq: toNat(n) = ℕ1 + x
    from apply nat_positive_suc[toNat(n)] to pos_n
  have eq2: fromNat(toNat(n)) = fromNat(ℕ1 + x) by replace eq.
  have eq3: n = fromNat(ℕ1) + fromNat(x)
    by { replace from_toNat | fromNat_add in eq2 }
  choose fromNat(x)
  conclude n = 1 + fromNat(x) by {
    expand lit | 2*fromNat | inc
    expand lit | 2*fromNat | inc in eq3
  }
end

theorem uint_zero_or_add_one: all x:UInt. x = 0 or (some x':UInt. x = 1 + x')
proof
  arbitrary x:UInt
  have zero_or_pos: x = 0 or 0 < x by uint_zero_or_positive[x]
  cases zero_or_pos
  case xz {
    xz
  }
  case xp {
    obtain x' where xs: x = 1 + x' from apply uint_positive_add_one to xp
    have G: some y:UInt. x = 1 + y by {
      choose x'
      xs
    }
    G
  }
end
  
theorem uint_trichotomy:
  all x:UInt, y:UInt.
  x < y  or  x = y  or  y < x
proof
  arbitrary x:UInt, y:UInt
  have tri: toNat(x) < toNat(y) or toNat(x) = toNat(y) or toNat(y) < toNat(x)
    by trichotomy[toNat(x), toNat(y)]
  cases tri
  case less {
    conclude x < y by apply less_toNat to less
  }
  case eq {
    conclude x = y by apply toNat_injective to eq
  }
  case greater {
    conclude y < x by apply less_toNat to greater
  }
end

theorem uint_less_implies_not_greater:
  all x:UInt, y:UInt.
  if x < y then not (y < x)
proof
  arbitrary x:UInt, y:UInt
  assume x_y
  have A: toNat(x) < toNat(y) by apply toNat_less to x_y
  have B: not (toNat(y) < toNat(x)) by apply less_implies_not_greater to A
  assume y_x
  have C: toNat(y) < toNat(x) by apply toNat_less to y_x
  conclude false by apply B to C
end

theorem uint_monus_add_assoc: all n:UInt, l:UInt,m:UInt.
  if m ≤ n
  then l + (n ∸ m) = (l + n) ∸ m
proof
  arbitrary n:UInt, l:UInt, m:UInt
  assume mn
  have mn2: toNat(m) ≤ toNat(n) by apply toNat_less_equal[m,n] to mn
  have lnm: toNat(l) + (toNat(n) ∸ toNat(m)) = (toNat(l) + toNat(n)) ∸ toNat(m)
    by apply monus_add_assoc[toNat(n), toNat(l), toNat(m)] to mn2
  suffices toNat(l + (n ∸ m)) = toNat((l + n) ∸ m) by toNat_injective
  replace toNat_add | toNat_monus | toNat_add
  lnm
end

theorem uint_zero_mult: all n:UInt. 0 * n = 0
proof
  arbitrary n:UInt
  expand lit | fromNat | operator*.
end

auto uint_zero_mult

postulate uint_mult_zero: all n:UInt. n * 0 = 0

auto uint_mult_zero

theorem uint_one_mult: all n:UInt.
  1 * n = n
proof
  arbitrary n:UInt
  suffices toNat(1 * n) = toNat(n) by toNat_injective
  replace toNat_mult
  evaluate
end

auto uint_one_mult

theorem uint_mult_one: all n:UInt.
  n * 1 = n
proof
  arbitrary n:UInt
  suffices toNat(n * 1) = toNat(n) by toNat_injective
  replace toNat_mult
  evaluate
end

auto uint_mult_one

theorem uint_dist_mult_add:
  all a:UInt, x:UInt, y:UInt.
  a * (x + y) = a * x + a * y
proof
  arbitrary a:UInt, x:UInt, y:UInt
  suffices toNat(a * (x + y)) = toNat(a * x + a * y) by toNat_injective
  replace toNat_mult | toNat_add | toNat_mult
  replace dist_mult_add.
end

postulate uint_dist_mult_add_right:
  all x:UInt, y:UInt, a:UInt.
  (x + y) * a = x * a + y * a

postulate uint_mult_to_zero: all n:UInt, m:UInt.
  (if n * m = 0 then n = 0 or m = 0)

postulate uint_less_equal_trans: all m:UInt. all n:UInt, o:UInt.
  (if m ≤ n and n ≤ o then m ≤ o)

postulate uint_less_equal_antisymmetric:
  all x:UInt, y:UInt. 
  (if x ≤ y and y ≤ x
  then x = y)

fun Even(n : UInt) {
  some m:UInt. n = 2 * m
}

fun Odd(n : UInt) {
  some m:UInt. n = 1 + (2 * m)
}

postulate uint_Even_or_Odd: all n:UInt. Even(n) or Odd(n)

postulate uint_odd_one_even: all n:UInt. if Odd(1 + n) then Even(n)

postulate uint_even_one_odd: all n:UInt. if Even(1 + n) then Odd(n)

postulate uint_Even_not_Odd: all n:UInt. Even(n) ⇔ not Odd(n)

postulate uint_div_mod: all n:UInt, m:UInt.
  if 0 < m
  then (n / m) * m + (n % m) = n

postulate uint_mod_less_divisor: all n:UInt, m:UInt. if 0 < m then n % m < m

fun divides(a : UInt, b : UInt) {
  some k:UInt. a * k = b
}

postulate uint_divides_mod: all d:UInt, m:UInt, n:UInt.
  if divides(d, n) and divides(d, m % n) and 0 < n then divides(d, m)

postulate uint_div_cancel: all y:UInt. if 0 < y then y / y = 1

postulate uint_mod_self_zero: all y:UInt. y % y = 0
      
postulate uint_zero_mod: all x:UInt. 0 % x = 0

postulate uint_zero_div: all x:UInt. if 0 < x then 0 / x = 0

postulate uint_mod_one: all n:UInt. n % 1 = 0

postulate uint_div_one: all n:UInt. n / 1 = n

postulate uint_add_div_one: all n:UInt, m:UInt.
  if 0 < m
  then (n + m) / m = 1 + n / m
  
postulate uint_mult_div_inverse: all n:UInt, m:UInt.
  (if 0 < m then (n * m) / m = n)

postulate uint_two_mult: all n:UInt. 2 * n = n + n

postulate uint_equal_implies_less_equal: all x:UInt, y:UInt. (if x = y then x ≤ y)

postulate uint_add_both_sides_of_less_equal: all x:UInt. all y:UInt, z:UInt. x + y ≤ x + z ⇔ y ≤ z

postulate uint_add_both_sides_of_le_equal: all x:UInt. all y:UInt, z:UInt. (x + y ≤ x + z) = (y ≤ z)

auto uint_add_both_sides_of_le_equal

theorem uint_zero_less_one_add: all n:UInt.
  0 < 1 + n
proof
  expand lit | 2*fromNat | inc
  uint_bzero_less_one_add
end

theorem uint_zero_le: all x:UInt.
  0 ≤ x
proof
  expand lit | fromNat
  uint_bzero_le
end

theorem uint_le_zero: all x:UInt.
  if x ≤ 0 then x = 0
proof
  expand lit | fromNat
  uint_le_bzero
end

theorem uint_monus_zero: all n:UInt. n ∸ 0 = n
proof
  expand lit | fromNat
  uint_monus_bzero
end

auto uint_monus_zero

theorem uint_zero_add: all x:UInt.
  0 + x = x
proof
  expand lit | fromNat
  uint_bzero_add
end

auto uint_zero_add

theorem uint_add_zero: all x:UInt.
  x + 0 = x
proof
  expand lit | fromNat
  uint_add_bzero
end
  
auto uint_add_zero

theorem uint_equal: all x:Nat, y:Nat.
  (fromNat(lit(x)) = fromNat(lit(y))) = (x = y)
proof
  arbitrary x:Nat, y:Nat
  expand lit
  suffices (fromNat(x) = fromNat(y)) ⇔ (x = y) by iff_equal
  have fwd: if fromNat(x) = fromNat(y) then x = y by fromNat_injective
  have bkwd: if x = y then fromNat(x) = fromNat(y) by assume eq replace eq.
  fwd , bkwd
end

auto uint_equal

theorem uint_monus_cancel: all n:UInt. n ∸ n = 0
proof
  expand lit | fromNat
  uint_monus_cancel_bzero
end

auto uint_monus_cancel

postulate uint_lit_less_equal: all x:Nat, y:Nat. (fromNat(lit(x)) ≤ fromNat(lit(y))) = (lit(x) ≤ lit(y))

auto uint_lit_less_equal

postulate uint_lit_less: all x:Nat, y:Nat. (fromNat(lit(x)) < fromNat(lit(y))) = (lit(x) < lit(y))

auto uint_lit_less

theorem uint_zero_less_one_add_true: all n:UInt. (0 < 1 + n) = true
proof
  arbitrary n:UInt
  apply eq_true to uint_zero_less_one_add[n]
end

auto uint_zero_less_one_add_true

theorem uint_add_to_zero: all n:UInt, m:UInt.
  if n + m = 0
  then n = 0 and m = 0
proof
  expand lit | fromNat
  uint_add_to_bzero
end
  
postulate uint_lit_div: all x:Nat, y:Nat. (fromNat(lit(x)) / fromNat(lit(y))) = fromNat(lit(x) / lit(y))

auto uint_lit_div

theorem uint_less_refl_false: all x:UInt.
  (x < x) = false
proof
  arbitrary x:UInt
  apply eq_false to uint_less_irreflexive[x]
end

auto uint_less_refl_false

theorem uint_one_add_zero_false: all n:UInt.
    (1 + n = 0) = false
proof
  arbitrary n:UInt
  apply eq_false to uint_not_one_add_zero[n]
end

auto uint_one_add_zero_false

