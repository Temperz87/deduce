import Nat

opaque union UInt {
  bzero         // 0
  dub_inc(UInt) // 2(1 + x)
  inc_dub(UInt) // 1 + 2x
}

private recursive inc(UInt) -> UInt {
  inc(bzero) = inc_dub(bzero)
  inc(dub_inc(x)) = inc_dub(inc(x))
  inc(inc_dub(x)) = dub_inc(x)
}

opaque recursive fromNat(Nat) -> UInt {
  fromNat(0) = bzero
  fromNat(suc(n)) = inc(fromNat(n))
}

opaque recursive toNat(UInt) -> Nat {
  toNat(bzero) = ℕ0
  toNat(dub_inc(x)) = ℕ2 * suc(toNat(x))
  toNat(inc_dub(x)) = suc(ℕ2 * toNat(x))
}

opaque recursive operator+(UInt, UInt) -> UInt {
  operator+(bzero, y) = y
  operator+(dub_inc(x), y) =
    switch y {
      case bzero { dub_inc(x) }
      case dub_inc(y') { dub_inc(inc(x + y')) }
      case inc_dub(y') { inc(dub_inc(x + y')) }
    }
  operator+(inc_dub(x), y) = 
    switch y {
      case bzero { inc_dub(x) }
      case dub_inc(y') { inc(dub_inc(x + y')) }
      case inc_dub(y') { inc(inc_dub(x + y')) }
    }
}

lemma two: ℕ1 + ℕ1 = ℕ2
proof
  evaluate
end

lemma two_four: ℕ2 * ℕ2 = ℕ4
proof
  evaluate
end

lemma one_three_four: ℕ1 + ℕ3 = ℕ4
proof
  evaluate
end

lemma four: ℕ2 + ℕ2 = ℕ4
proof
  evaluate
end

lemma three: ℕ1 + ℕ2 = ℕ3
proof
  evaluate
end

lemma toNat_inc: all x:UInt. toNat(inc(x)) = suc(toNat(x))
proof
  induction UInt
  case bzero {
    evaluate
  }
  case dub_inc(x) assume IH {
    expand inc | toNat | operator*
    replace IH.
  }
  case inc_dub(x) assume IH {
    suffices __ by evaluate
    replace add_suc.
  }
end

theorem toNat_add: all x:UInt, y:UInt.
  toNat(x + y) = toNat(x) + toNat(y)
proof
  induction UInt
  case bzero {
    arbitrary y:UInt
    evaluate
  }
  case dub_inc(x') assume IH {
    arbitrary y:UInt
    expand operator+
    switch y {
      case bzero { evaluate }
      case dub_inc(y') {
        expand toNat
        replace toNat_inc | suc_one_add | suc_one_add | two
        | dist_mult_add | two_four | suc_one_add | two | one_three_four
        show ℕ4 + ℕ2 * toNat(x' + y') = ℕ2 + ℕ2 * toNat(x') + ℕ2 + ℕ2 * toNat(y')
        replace IH[y']
        replace dist_mult_add | add_commute[ℕ2*toNat(x'),ℕ2] | four.
      }
      case inc_dub(y') {
        expand inc | toNat
        replace toNat_inc | suc_one_add | suc_one_add | two 
        | dist_mult_add | add_commute[ℕ2*toNat(x'),ℕ1] | add_commute[ℕ2,ℕ1]
        | three
        show ℕ3 + ℕ2 * toNat(x' + y') = ℕ3 + ℕ2 * toNat(x') + ℕ2 * toNat(y')
        replace IH[y']
        replace dist_mult_add.
      }
    }
  }
  case inc_dub(x') assume IH {
    arbitrary y:UInt
    switch y {
      case bzero { evaluate }
      case dub_inc(y') {
        expand operator+ | toNat | inc
        replace toNat_inc | suc_one_add | suc_one_add | two
          | dist_mult_add | add_commute[ℕ2*toNat(x'), ℕ2] | three
        show ℕ3 + ℕ2 * toNat(x' + y') = ℕ3 + ℕ2 * toNat(x') + ℕ2 * toNat(y')
        replace IH[y']
        replace dist_mult_add.
      }
      case inc_dub(y') {
        expand operator+ | toNat | inc
        replace suc_one_add | suc_one_add | dist_mult_add
          | two | add_commute[ℕ2*toNat(x'), ℕ1] | two
        show ℕ2 + ℕ2 * toNat(x' + y') = ℕ2 + ℕ2 * toNat(x') + ℕ2 * toNat(y')
        replace IH[y']
        replace dist_mult_add.
      }
    }
  }
end

theorem toNat_injective: all x:UInt, y:UInt.
  if toNat(x) = toNat(y) then x = y
proof
  induction UInt
  case bzero {
    arbitrary y:UInt
    expand toNat
    switch y {
      case bzero { . }
      case dub_inc(y') { evaluate }
      case inc_dub(y') { . }
    }
  }
  case dub_inc(x') assume IH {
    arbitrary y:UInt
    switch y {
      case bzero { evaluate }
      case dub_inc(y') {
        expand toNat
        replace suc_one_add | two | dist_mult_add
        suffices if ℕ2 + ℕ2 * toNat(x') = ℕ2 + ℕ2 * toNat(y')
                 then dub_inc(x') = dub_inc(y')  by evaluate
        assume prem
        have A: ℕ2 * toNat(x') = ℕ2 * toNat(y')
          by apply add_both_sides_of_equal to prem
        have B: toNat(x') = toNat(y')
          by apply mult_left_cancel to A
        have: x' = y' by apply IH to B
        conclude dub_inc(x') = dub_inc(y')
          by replace recall x' = y'.
      }
      case inc_dub(y') {
        expand toNat
        replace suc_one_add | two | dist_mult_add
        assume prem
        have even: EvenNat(ℕ2 + ℕ2*toNat(x')) by {
          expand EvenNat
          choose ℕ1 + toNat(x')
          replace dist_mult_add.
        }
        have even2: EvenNat(ℕ1 + ℕ2*toNat(y')) by {
          replace prem in even
        }
        have odd: OddNat(ℕ1 + ℕ2*toNat(y')) by {
          expand OddNat
          choose toNat(y')
          evaluate
        }
        conclude false by apply (apply Even_not_Odd to even2) to odd
      }
    }
  }
  case inc_dub(x') assume IH {
    arbitrary y:UInt
    switch y {
      case bzero { evaluate }
      case dub_inc(y') {
        expand toNat replace suc_one_add | two | dist_mult_add
        assume prem
        have odd: OddNat(ℕ1 + ℕ2*toNat(x')) by {
          expand OddNat
          choose toNat(x')
          evaluate
        }
        have even: EvenNat(ℕ2 + ℕ2*toNat(y')) by {
          expand EvenNat
          choose ℕ1 + toNat(y')
          replace dist_mult_add.
        }
        have odd2: OddNat(ℕ2 + ℕ2*toNat(y')) by replace prem in odd
        conclude false by apply (apply Even_not_Odd to even) to odd2
      }
      case inc_dub(y') {
        expand toNat replace suc_one_add
        assume prem
        have A: ℕ2 * toNat(x') = ℕ2 * toNat(y')
          by apply add_both_sides_of_equal to prem
        have B: toNat(x') = toNat(y')
          by apply mult_left_cancel[ℕ1, toNat(x'), toNat(y')] to A
        have: x' = y' by apply IH to B
        conclude inc_dub(x') = inc_dub(y') by replace recall x' = y'.
      }
    }
  }
end

theorem to_fromNat: all x:Nat. toNat(fromNat(x)) = x
proof
  induction Nat
  case 0 {
    evaluate
  }
  case suc(x') assume IH {
    suffices __ by evaluate
    replace toNat_inc | IH.
  }
end

theorem uint_zero_add: all x:UInt.
  fromNat(ℕ0) + x = x
proof
  arbitrary x:UInt
  suffices toNat(fromNat(ℕ0) + x) = toNat(x)   by toNat_injective
  equations
      toNat(fromNat(ℕ0) + x)
        = toNat(fromNat(ℕ0)) + toNat(x)   by toNat_add
    ... = ℕ0 + toNat(x)   by replace to_fromNat.
    ... = toNat(x)        by .
end

auto uint_zero_add

theorem uint_add_zero: all x:UInt.
  x + fromNat(ℕ0) = x
proof
  arbitrary x:UInt
  suffices toNat(x + fromNat(ℕ0)) = toNat(x) by toNat_injective
  equations
  	toNat(x + fromNat(ℕ0)) 
      = toNat(x) + toNat(fromNat(ℕ0))    by toNat_add
  ... = toNat(x) + ℕ0                    by replace to_fromNat.
  ... = toNat(x)                         by .
end

auto uint_add_zero

theorem uint_add_commute: all x:UInt, y:UInt.
  x + y = y + x
proof
  arbitrary x:UInt, y:UInt
  suffices toNat(x + y) = toNat(y + x) by toNat_injective
  equations
	    toNat(x + y)
        = toNat(x) + toNat(y)   by toNat_add
    ... = toNat(y) + toNat(x)   by add_commute
    ... = #toNat(y + x)#        by replace toNat_add.
end

theorem uint_add_assoc: all x:UInt, y:UInt, z:UInt.
  (x + y) + z = x + (y + z)
proof
  arbitrary x:UInt, y:UInt, z:UInt
  suffices toNat((x + y) + z) = toNat(x + (y + z)) by toNat_injective
  equations
	    toNat((x + y) + z)
        = toNat(x + y) + toNat(z)              by toNat_add
    ... = toNat(x) + toNat(y) + toNat(z)       by replace toNat_add.
    ... = toNat(x) + #toNat(y + z)#            by replace toNat_add.
    ... = #toNat(x + (y + z))#                 by replace toNat_add.
end

associative operator+ in UInt

theorem fromNat_add: all x:Nat, y:Nat.
  fromNat(x) + fromNat(y) = fromNat(x + y)
proof
  arbitrary x:Nat, y:Nat
  suffices toNat(fromNat(x) + fromNat(y)) = toNat(fromNat(x + y))
    by toNat_injective
  replace toNat_add | to_fromNat.
end

auto fromNat_add
