# Abstract Syntax

*Work in progress*

The file contains an overview of each of the abstract syntax
tree nodes defined in [`abstract_syntax.py`](../../abstract_syntax.py)

This file uses Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
to generate `__init__` methods for the classes.


## Base classes

### AST

Superclass for all ast nodes

Properties:
- `location : Meta` - The location in the deduce file of the text corresponding to the ast node

### Type, Term, Proof, Statement,

Abstract datatypes for categories of AST nodes. Include 
default methods for operations such as `copy`, `uniquify`, and `reduce` that throw errors for lacking implementations.

### TODO: Formula, Pattern

## Types

### IntType
TODO: I think this is deprecated


### BoolType
`BoolType(location)`
```
define b : bool = true
//         ^^^^
```

Type for booleans.


### TypeType
`TypeType(location)`
The type of types
```
define T : type = bool
//         ^^^^
```

### OverloadType
TODO: I think this is deprecated


### FunctionType
`FunctionType(location, type_params, param_types, return_type)`
```
define f : fn <T> T, T -> T = fun<T> x, y { x }
//         ^^^^^^^^^^^^^^^^
```
Type for functions

Properties:
- `type_params` -
- `param_types` -
- `return_type` - 

### ArrayType
`ArrayType(location, elt_type)`
```
define A : [bool] = array([true])
//         ^^^^^^
```
Type for arrays

Properties
- `elt_type` -

### TypeInst
`TypeInst(location, typ, arg_types)`
```
define A : List<Nat> = []
//         ^^^^^^^^^
```
Type representing instantiated generics

Properties
- `typ` - The base type
- `arg_types` - The arguments supplied

### GenericUnknownInst
`GenericUnknownInst(location, typ)`
This is the type of a constructor such as `empty` of a generic union when we do not yet know the type arguments.
This ast node is generated by the checker when it encounters a union constructor without a provided type,
such as in
```
print empty
```

Properties
- `typ` - The base type

## Patterns

Patterns are used in matching situations (`recursive`, `switch`, `induction`) to bind new variables as necessary
and delineate cases.

### PatternBool
`PatternBool(location, value)`
```
switch b {
  case true {
//     ^^^^
    ...
  }
  case false {
//     ^^^^^
    ...
  }
}

```


Properties
- `value` - The bool being matched by the case

### PatternCons
`PatternCons(location, constructor, parameters)`
```
induction List
case empty {
//   ^^^^^
  ?
}
case node(n, ns') {
//   ^^^^^^^^^^^^
  ?
}
```

Used for matching on union constructors

Properties:
- `constructor` - Typically a var, the union constructor being matched on
- `parameters` - Any parameters of the constructor that need to be bound

## Terms
Terms are like expressions

### Generic
`Generic(location, typeof, type_params, body)`
```
generic E { fun x { x } }
```

Used in declaring generic functions

Properties
- `type_params` - The type parameters
- `body`

### Conditional
`Conditional(location, typeof, cond, thn, els)`
```
if true then 42 else 0
```

`"if" cond "then" thn "else" els`


Properties
- `cond` -
- `thn` -
- `els` - 

### TAnnote
`TAnnote(location, typeof, subject, typ)`
```
print 42 : Nat
//    ^^^^^^^^
```

A term with a type annotation

### Var
`Var(location, typeof, name, resolved_names)`

Ast node for use of variables.

Name is established upon creation in the parser, then updated during type checking.

Resolved names is filled in during uniquify,
and is a list because of overloading.

### Int
`Int(location, typeof, value)`

TODO: Deprecated?


### Lambda
`Lambda(location, typeof, vars, body)`

```
fun x : bool { x }
```

### Call
`Call(location, typeof, rator, args)`

```
4 + 40

node(x, empty)

length(ls)
```

Used for union constructors, infix operators, and functions.

### Switch
See also SwitchProf

`Switch(location, typeof, subject, cases)`

```
print switch b { case true { false } case false { true } }
//    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

Properties:
- cases is a list of [SwitchCase](#switchcase) ast nodes.

This is for when a switch behaves as a term

#### SwitchCase
`SwitchCase(location, pattern, body)`

Pattern is a [pattern](#patterns).


### TermInst
`TermInst(location, typeof, subject, type_args, inferred)`

```
@[]<Nat>
```
Also generated by the type checker.


Properties
- `subject` - The term being instantiated
- `type_args` - The arguments being used to instantiate
- `inferred` - A boolean value indicating whether the inst was inferred by the type checker or supplied by the user. This value is used to determine whether to print the annotation when printing the node.

### Array
`Array(location, typeof, elements)`

TODO: Is this used anywhere?

### MakeArray
`MakeArray(location, typeof, subject)`

```
array([1, 2, 3, 4])
```

The subject must be of type `List` as defined in `List.pf`.

### ArrayGet
`ArrayGet(location, typeof, subject, position)`

```
define A = array([42])
print A[0]
//    ^^^^
```

### TLet
`TLet(location, typeof, var, rhs, body)`

```
define front = first(search(xs, y));
  define back = second(search(xs, y));
    (back = [] or head(back) = just(y)) and
    not (y âˆˆ set_of(front)) and
    front ++ back = xs 
```

This is a `define` in the context of a term

### Hole
`Hole(location, typeof)`

```
suffices ? by evaluate
//       ^
```

This is different from PHole.



### Omitted
`Omitted(location, typeof)`

```
suffices __ by evaluate
//       ^^
```


### Mark
`Mark(location, typeof, subject)`

```
# true #
```

Wraps another term. Marks are used to specify where to use rewrites and definitions when chaining equations.

## Formulas